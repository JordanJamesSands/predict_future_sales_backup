{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load Dependencies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np \n",
    "import pickle\n",
    "import xgboost as xgb\n",
    "import time\n",
    "import graphviz\n",
    "import matplotlib as plt\n",
    "import re"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Set Global Variables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "START_NOTEBOOK = time.time()\n",
    "SUB=False\n",
    "AVE= False\n",
    "NMF_DIM = 40"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_train , x_test , y_train , y_test = pickle.load(open('../saved_datasets/19-3-19,pipeline_A_reduced_frommaster,dateback=18/xtrain_xtest_ytrain_ytest.pickle','rb'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preprocessing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Try averaging some features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ave_feats(df):\n",
    "    feats = [     \n",
    "     'sum_item_sales_back_',\n",
    "     'sum_shop_sales_back_',\n",
    "     'item_cnt_month_back_',\n",
    "     'sum_item_cat_sales_back_',\n",
    "     'sum_city_back_',\n",
    "     'sum_itemtype_back_',\n",
    "     'sum_iteminfo_back_'\n",
    "            ]\n",
    "    df = df.copy()\n",
    "    for feat in feats:\n",
    "        print('averaging on '+feat+'...')\n",
    "        for i in np.arange(1,18,3):\n",
    "            df['ave_'+feat+str(i)] = (df[feat+str(i)]+df[feat+str(i+1)]+df[feat+str(i+2)])/3\n",
    "        reduced_cols = [a for a in df.columns.tolist() if not re.match('^'+feat,a)]\n",
    "        df = df[reduced_cols]\n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "if AVE:\n",
    "    x_train = list(map(ave_feats,x_train))\n",
    "    x_test = list(map(ave_feats,x_test))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Try culling early data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_train_saved = x_train\n",
    "y_train_saved = y_train\n",
    "x_train = []\n",
    "y_train = []\n",
    "CUTOFF = 25\n",
    "for xtrain_el , ytrain_el in zip(x_train_saved,y_train_saved):\n",
    "    x_train.append(xtrain_el[xtrain_el.date_block_num>CUTOFF])\n",
    "    y_train.append(ytrain_el[xtrain_el.date_block_num>CUTOFF])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Other Preproc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def preproc_model3(x_train,x_test,y_train,y_test):\n",
    "\n",
    "    x_train = [d.drop(['shop_id','item_id','item_category_id','city','item_type','item_info','month'],axis=1) for d in x_train]\n",
    "    x_test =  [d.drop(['shop_id','item_id','item_category_id','city','item_type','item_info','month'],axis=1) for d in x_test]\n",
    "    y_train = [d.clip(0,20) for d in y_train]\n",
    "    y_test =  [d.clip(0,20) for d in y_test]\n",
    "    return [x_train,x_test,y_train,y_test]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_train , x_test , y_train , y_test = preproc_model3(x_train,x_test,y_train,y_test)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Feature Selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#x_train[0].columns.tolist()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "feat_list= []\n",
    "#feat_list = ['_'+str(x)+'$' for x in range(7,19)] + []\n",
    "#feat_list = ['iteminfo','item_cat','city','item_sales']\n",
    "feat_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def quickdrop(df):\n",
    "    cols_keep = df.columns.tolist()\n",
    "    for feat in feat_list:\n",
    "        cols_keep = [c for c in cols_keep if not re.match('.*'+feat,c)]\n",
    "    return df[cols_keep]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x_train = list(map(quickdrop,x_train))\n",
    "x_test = list(map(quickdrop,x_test))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#x_train[0].columns.tolist()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = xgb.XGBRegressor(\n",
    "    seed=0,\n",
    "    max_depth=2,\n",
    "    learning_rate=0.5,\n",
    "    n_estimators=1000,\n",
    "    objective='reg:linear',\n",
    "    nthread=7,\n",
    "#    min_child_weight=100,\n",
    "    colsample_bytree=0.8,\n",
    "    subsample=0.8\n",
    ")\n",
    "eval_set = [(x_train[0],y_train[0]),(x_test[0],y_test[0])]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model.fit(\n",
    "    verbose=True,\n",
    "    X=x_train[0],\n",
    "    y=y_train[0],\n",
    "    eval_set=eval_set,\n",
    "    early_stopping_rounds=50\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('CUTOFF='+str(CUTOFF))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "deval = model.evals_result()\n",
    "val0 = deval['validation_0']['rmse']\n",
    "val1 = deval['validation_1']['rmse']\n",
    "deval = pd.DataFrame({'val0':val0,'val1':val1})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "time.sleep(0.2)\n",
    "deval.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "###### ax = xgb.plot_importance(model,height=0.8,)\n",
    "print(ax.figure.set_size_inches(5,10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%env PATH=C:\\Program Files (x86)\\Graphviz2.38\\bin\n",
    "#ax = xgb.plot_tree(model)\n",
    "#ax.figure.set_size_inches(20,20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gain = pd.Series(model.get_booster().get_score(importance_type='gain'))\n",
    "gain = gain.sort_values(ascending=True)\n",
    "type(gain)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ax = gain.plot(kind='barh')\n",
    "ax.figure.set_size_inches(10,20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = x_train[0].copy()\n",
    "df['target'] = y_train[0]\n",
    "df.groupby('new_item').target.mean().plot(kind='bar')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dft = x_test[0].copy()\n",
    "dft['target'] = y_test[0]\n",
    "dft.groupby('new_item').target.mean().plot(kind='bar')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#d = pd.DataFrame()\n",
    "d = {}\n",
    "coltypes=[  \n",
    " 'sum_item_sales_back_',\n",
    " 'sum_shop_sales_back_',\n",
    " 'item_cnt_month_back_',\n",
    " 'sum_item_cat_sales_back_',\n",
    " 'sum_item_cat_shop_sales_back_',\n",
    " 'sum_city_back_',\n",
    " 'sum_itemtype_back_',\n",
    " 'sum_iteminfo_back_',\n",
    " 'sum_city_item_back_',\n",
    " 'sum_city_item_cat_back_',\n",
    " 'sum_itemtype_shop_back_',\n",
    " 'sum_itemtype_city_back_']\n",
    "save=[]\n",
    "for ct in coltypes:\n",
    "    save.append(gain.filter(regex=ct))\n",
    "    d[ct] = np.sum(gain.filter(regex=ct))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sorted(d.items(),key=lambda t: t[1],reverse=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.sum(save[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "len(gain)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pd.Series(gain)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Retrain model with all data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Write Submission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "SUB=True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "del model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "model = xgb.XGBRegressor(\n",
    "    seed=0,\n",
    "    max_depth=2,\n",
    "    learning_rate=0.5,\n",
    "    n_estimators=194,\n",
    "    objective='reg:linear',\n",
    "    nthread=7,\n",
    "#    min_child_weight=100,\n",
    "    colsample_bytree=0.8,\n",
    "    subsample=0.8\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#retrain on all data\n",
    "model.fit(\n",
    "    verbose=True,\n",
    "    X=x_train[1],\n",
    "    y=y_train[1],\n",
    "    eval_set=eval_set\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "if SUB:\n",
    "    print('predicting...')\n",
    "    preds = model.predict(x_test[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import datetime\n",
    "str(datetime.datetime.now()).replace(':','.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "submission = pd.DataFrame({'ID':np.arange(0,214200),'item_cnt_month':preds})\n",
    "submission.to_csv('../gen_data/submission'+str(datetime.datetime.now()).replace(':','.')+'.csv',index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adjusting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "submission['item_cnt_month'] = 0.2839365/submission.item_cnt_month.mean() * submission.item_cnt_month\n",
    "submission.to_csv('../gen_data/submission_adjusted_'+str(datetime.datetime.now()).replace(':','.')+'.csv',index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
